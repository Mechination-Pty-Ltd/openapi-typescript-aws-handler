import { Handler } from "aws-lambda";
import { FilterKeys, OkStatus, ErrorStatus } from "openapi-typescript-helpers"


export type OperationResponseWithoutContent<SC, H> = {
    statusCode: SC,
    headers?: H,
    contentType?: never;
    content?: never;
}


export type OperationResponseWithContent<SC, CT, H, X> = {
    statusCode: SC,
    headers?: H,
    contentType: CT,
    content: X,
}

export type OperationInputWithRequestBody<P, CT, RB> =  {
    parameters: P
    contentType: CT,
    body: RB,
}

export type OperationInputWithoutRequestBody<P> = {
    parameters: P
}

export type RedirectionStatus = 300 | 301 | 302 | 303 | 304 | 307 | 308;
export type AnyStatus = OkStatus | ErrorStatus | RedirectionStatus;



/**
 * The hander expects an input in this format. 
 */
export interface ApiCallInput {
    operationId: string
    body: string|null
    params: {
        path: Record<string,string> | undefined
        query: Record<string,string> | undefined
    };
}

/**
 * Result that the handler replies with.
 */
export interface ApiCallResult {
    statusCode: number;
    headers: Record<string,string>;
    body?: string|null;
}



type OperationInput<OP extends {}> = FilterKeys<OP, "requestBody"> extends never ? OperationInputWithoutRequestBody<any> : OperationInputWithRequestBody<any, any, any>;
type OperationOutput<OP> = OperationResponseWithContent<any, any, any, any> | OperationResponseWithoutContent<any, any>

type OperationHandler<OP extends {}> = (input: OperationInput<OP>) => Promise<OperationOutput<OP>>



/**
 * By default, the handler doesn't log anything.  If you supply DEBUG_API to the lambda's environment, it
 * will log instead. 
 */
function logDebug(msg: string, ...args: any) {
    if (process.env.DEBUG_API) {
        console.log(msg, ...args);
    }
}

type GenericResponse = Record<string, {
    headers: Record<string,string>
    content: any
}>

/** 
 * Used to make the handler code below a bit more type safe.  It is reasonable to assume that every API 
 * generated by openapi-typescript will sort of conform to a more strict form of this shape
 */
type GenericOperation = {
    body: {
        content: {
          "applicaiton/json": any
        };
    };
    parameters: {
        path: Record<string,string> | undefined,
        query: Record<string,string> | undefined,
    }
    responses: Record<string,GenericResponse>
}


/**
 * a Non-2xx response type to return to the caller. Each operation has only one normal response, 
 * which should be a 2xx type.  To allow other responses (sometimes called errors), throw one of 
 * these from within your code, and it will be returned as
 * such to the client.  This is less type-controlled than the main handlers, so make sure the generic
 * type that you specify here lines up with a type defined in your OpenAPI spec.
 */
export class Non2xxResult<C extends {}> extends Error {
    statusCode: number;
    content: C;

    constructor(content: C, statusCode: number = 500) {
        super("An non 2xx result has been returned");
        this.content = content;
        this.statusCode = statusCode;
    }
}



/**
 * Creates an AWS Lambda compatible handler function that will take inputs in our custom format, call the appropriate
 * handler, then return the result. 
 * 
 * Note that the format used here is not the standard API Gateway Proxy request form.
 * 
 * @param apiHandler The input to pass to the API call - It is assumed that this has already been validated and is in a format appropriate for the operation being called.
 * @returns the result. 
 */
export function makeOpenApiLambdaHandler<OPS extends {}>(apiHandler: OPS): Handler<ApiCallInput, ApiCallResult> {
    return async (evt) => {
        logDebug("Invoking API", JSON.stringify(evt));    
        try {
            if (!(evt.operationId in apiHandler)) {
                return {
                    statusCode: 404,
                    headers: {},
                    body: JSON.stringify({ message: `Operation ${evt.operationId} not present`})
                }
            }
            const handler: OperationHandler<GenericOperation> = (apiHandler as any)[evt.operationId];
            const input: OperationInputWithRequestBody<any, any, any> = {
                body: evt.body ? JSON.parse(evt.body) : null,
                contentType: "application/json",
                parameters: evt.params,
            };
            const response = await handler(input);
            logDebug("Response", response);

            return {
                statusCode: parseInt(response.statusCode),
                headers: {
                    ...(response.headers as Record<string,string>),
                    "Content-Type": response.contentType
                },
                body: response.content ? JSON.stringify(response.content) : null
            }
        } catch (ex: any) {
            if (ex instanceof Non2xxResult) {
                logDebug("API raised ", ex.statusCode, "result with content", ex.content);
                return {
                    statusCode: ex.statusCode,
                    headers: {
                        "Content-Type": JSON_CONTENT_TYPE
                    },
                    body: typeof(ex.content) === 'string' ? ex.content : JSON.stringify(ex.content)
                }
            }
            console.error("An unhandled error occurred", ex);
            return {
                statusCode: 500,
                headers: {
                    "Content-Type": JSON_CONTENT_TYPE
                },
                body: JSON.stringify({ message: "An error occurred"})
            }
        }
    }
}


export const JSON_CONTENT_TYPE = "application/json";