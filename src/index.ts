import { Handler } from "aws-lambda";
import { FilterKeys, OkStatus, ErrorStatus } from "openapi-typescript-helpers"


export type OperationResponseWithoutContent<SC, H> = {
    statusCode: SC,
    headers?: H,
    contentType?: never;
    content?: never;
}


export type OperationResponseWithContent<SC, CT, H, X> = {
    statusCode: SC,
    headers?: H,
    contentType: CT,
    content: X,
}

export type OperationInputWithRequestBody<P, CT, RB> =  {
    parameters: P
    contentType: CT,
    body: RB,
}

export type OperationInputWithoutRequestBody<P> = {
    parameters: P
}

export type RedirectionStatus = 300 | 301 | 302 | 303 | 304 | 307 | 308;
export type AnyStatus = OkStatus | ErrorStatus | RedirectionStatus;

export { deref } from "./utils";


/**
 * The hander expects an input in this format. 
 */
export interface ApiCallInput {
    operationId: string
    body: string|null
    params: {
        path: Record<string,string> | undefined
        query: Record<string,string> | undefined
    };
}

/**
 * Result that the handler replies with.
 */
export interface ApiCallResult {
    statusCode: number;
    headers: Record<string,string>;
    body?: string|null;
    cookies?: string[];
}



type OperationInput<OP extends {}> = FilterKeys<OP, "requestBody"> extends never ? OperationInputWithoutRequestBody<any> : OperationInputWithRequestBody<any, any, any>;
type OperationOutput<OP> = OperationResponseWithContent<any, any, any, any> | OperationResponseWithoutContent<any, any>

type OperationHandler<OP extends {}> = (input: OperationInput<OP>) => Promise<OperationOutput<OP>>



/**
 * By default, the handler doesn't log anything.  If you supply DEBUG_API to the lambda's environment, it
 * will log instead. 
 */
function logDebug(msg: string, ...args: any) {
    if (process.env.DEBUG_API) {
        console.log(msg, ...args);
    }
}

type GenericResponse = Record<string, {
    headers: Record<string,string>
    content: any
}>

/** 
 * Used to make the handler code below a bit more type safe.  It is reasonable to assume that every API 
 * generated by openapi-typescript will sort of conform to a more strict form of this shape
 */
type GenericOperation = {
    body: {
        content: {
          "applicaiton/json": any
        };
    };
    parameters: {
        path: Record<string,string> | undefined,
        query: Record<string,string> | undefined,
    }
    responses: Record<string,GenericResponse>
}


/**
 * a Non-2xx response type to return to the caller. Each operation has only one normal response, 
 * which should be a 2xx type.  To allow other responses (sometimes called errors), throw one of 
 * these from within your code, and it will be returned as
 * such to the client.  This is less type-controlled than the main handlers, so make sure the generic
 * type that you specify here lines up with a type defined in your OpenAPI spec.
 */
export class Non2xxResult<C extends {}> extends Error {
    statusCode: number;
    content: C;

    constructor(content: C, statusCode: number = 500) {
        super("An non 2xx result has been returned");
        this.content = content;
        this.statusCode = statusCode;
    }
}

function mapCookies(val: unknown): string[] {
    if (val !== undefined) {
        if (Array.isArray(val)) {
            return val.filter(i => typeof(i) === 'string')
        }
        if (typeof(val) === 'string') {
            return [val]
        }
    }
    return [];
}

function normaliseHeaders(val: Record<string,string>) {
    return Object.fromEntries(Object.entries(val).map(([k,v]) => [k.toLowerCase(), v]))

}


/**
 * Creates an AWS Lambda compatible handler function that will take inputs in our custom format, call the appropriate
 * handler, then return the result. 
 * 
 * Note that the format used here is not the standard API Gateway Proxy request form.
 * 
 * @param apiHandler The input to pass to the API call - It is assumed that this has already been validated and is in a format appropriate for the operation being called.
 * @returns the result. 
 */
export function makeOpenApiLambdaHandler<OPS extends {}>(apiHandler: OPS): Handler<ApiCallInput, ApiCallResult> {
    return async (evt) => {
        logDebug("Invoking API", JSON.stringify(evt));    
        try {
            if (!(evt.operationId in apiHandler)) {
                return {
                    statusCode: 404,
                    headers: {},
                    body: JSON.stringify({ message: `Operation ${evt.operationId} not present`})
                }
            }
            const handler: OperationHandler<GenericOperation> = (apiHandler as any)[evt.operationId];
            const input: OperationInputWithRequestBody<any, any, any> = {
                body: evt.body ? JSON.parse(evt.body) : null,
                contentType: "application/json",
                parameters: evt.params,
            };
            const response = await handler(input);
            logDebug("Response", response);

            let body: string|null|undefined;

            if (response.content) {
                if (response.contentType === 'application/json') {
                    body = JSON.stringify(response.content);
                } else {
                    if (typeof(response.content) !== 'string') {
                        // TODO Should this be a 500 error?
                        console.log("WARNING: Function returned non-string data when deailing with content-type ", response.contentType);
                    }
                    body = response.content?.toString()
                }
            } else {
                body = "";
            }


            const headers: Record<string,string> = response.headers ? normaliseHeaders(response.headers) : {};
            // Cookies are treated separately from other headers, as they may have multiple values. 
            let cookies: string[] = [];
            const SET_COOKIE_HEADER = 'set-cookie'
            if (headers[SET_COOKIE_HEADER]) {
                cookies = mapCookies(headers[SET_COOKIE_HEADER]);
                delete headers[SET_COOKIE_HEADER];
            }
            // all other headers must be single value
            if (Object.entries(headers).find(([k,v]) => typeof(v) !== 'string'))  {
                console.log("Headers are ", headers);
                throw new Error("All Header responses must be single valued strings (except for Set-Cookie)")
            }

            if (response.contentType) {
                headers['content-type'] = response.contentType;
            }

            const res: ApiCallResult = {
                statusCode: parseInt(response.statusCode),
                headers,
                cookies,
                body,
            }
            return res;
        } catch (ex: any) {
            if (ex instanceof Non2xxResult) {
                logDebug("API raised ", ex.statusCode, "result with content", ex.content);
                return {
                    statusCode: ex.statusCode,
                    headers: {
                        "Content-Type": JSON_CONTENT_TYPE
                    },
                    body: typeof(ex.content) === 'string' ? ex.content : JSON.stringify(ex.content)
                }
            }
            console.error("An unhandled error occurred", ex);
            throw ex; // We want this to show up as an error in the lambda metrics.  The proxy handler will mask with the error message 
        }
    }
}


export const JSON_CONTENT_TYPE = "application/json";