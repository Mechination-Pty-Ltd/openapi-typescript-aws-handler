import { Handler } from "aws-lambda";
import { SuccessResponse, OperationRequestBodyContent, ResponseObjectMap, FilterKeys, OkStatus } from "openapi-typescript-helpers"



/**
 * Interface that the handler expects
 */
export interface ApiCallInput {
    operationId: string
    body: string|null
    params: {
        path: Record<string,string> | undefined
        query: Record<string,string> | undefined
    };
}

/**
 * Result that the handler replies with.
 */
export interface ApiCallResult {
    statusCode: number
    body?: string|null
}


export type OperationInput<OP> = {
    body: OperationRequestBodyContent<OP>
    params: FilterKeys<OP, "parameters">
}


export type OperationResultWrapper<R> = {
    status: number;
    content: R
}
export type OperationJsonOutput<OP> = OperationResultWrapper<FilterKeys<ResponseObjectMap<OP>, OkStatus> extends { content: never } ? null : FilterKeys<SuccessResponse<ResponseObjectMap<OP>>, "application/json">>;
export type OperationHandler<OP> = (props: OperationInput<OP>) => Promise<OperationJsonOutput<OP>>

/**
 * List of all operations for a service against a function that can handle that operation
 * and return an appropriate 2xx response. In the event the operation has no 200 applicaiton/json
 * response, the return type will be void.
 * 
 * The return type will be based on the first 2xx response defined in the openAPI specification. 
 * If there are more than one 2xx responses, throw a Non2xxResult for any other values. 
 */
export type OperationHandlers<Ops extends {}> = {
    [K in keyof Ops]: OperationHandler<Ops[K]>
};


/**
 * a Non-2xx response type to return to the caller. Each operation has only one normal response, 
 * which should be a 2xx type.  To allow other responses (sometimes called errors), throw one of 
 * these from within your code, and it will be returned as
 * such to the client.  This is less type-controlled than the main handlers, so make sure the generic
 * type that you specify here lines up with a type defined in your OpenAPI spec.
 */
export class Non2xxResult<C extends {}> extends Error {
    statusCode: number;
    content: C;

    constructor(content: C, statusCode: number = 500) {
        super("An non 2xx result has been returned");
        this.content = content;
        this.statusCode = statusCode;
    }
}

/** 
 * Used to make the handler code below a bit more type safe.  It is reasonable to assume that every API 
 * generated by openapi-typescript will sort of conform to a more strict form of this shape
 */
type GenericOperation = {
    requestBody: {
        content: {
          "applicaiton/json": any
        };
    };
    parameters: {
        path: Record<string,string> | undefined,
        query: Record<string,string> | undefined,
    }
    responses: {
        200: {
            content: {
                "application/json": any
            }
        }
    } 
}


/**
 * By default, the handler doesn't log anything.  If you supply DEBUG_API to the lambda's environment, it
 * will log instead. 
 */
function logDebug(msg: string) {
    if (process.env.DEBUG_API) {
        console.log(msg);
    }
}



/**
 * Creates an AWS Lambda compatible handler function that will take inputs in our custom format, call the appropriate
 * handler, then return the result. 
 * 
 * Note that the format used here is not the standard API Gateway Proxy request form.
 * 
 * @param apiHandler The input to pass to the API call - It is assumed that this has already been validated and is in a format appropriate for the operation being called.
 * @returns the result. 
 */
export function makeOpenApiLambdaHandler<OPS extends {}>(apiHandler: OperationHandlers<OPS>): Handler<ApiCallInput, ApiCallResult> {
    return async (evt) => {
        logDebug(`Invoking API ${JSON.stringify(evt)}`);    
        try {
            if (!(evt.operationId in apiHandler)) {
                return {
                    statusCode: 404,
                    body: JSON.stringify({ message: `Operation ${evt.operationId} not present`})
                }
            }
            const handler: OperationHandler<GenericOperation> = (apiHandler as any)[evt.operationId];
            const result = await handler({
                body: evt.body && JSON.parse(evt.body) ,
                params: evt.params,
            });
            logDebug(`Response ${JSON.stringify(result)}`);
            return {
                statusCode: result.status,
                body: result.content && JSON.stringify(result.content),
            }
        } catch (ex: any) {
            if (ex instanceof Non2xxResult) {
                logDebug(`API raised ${ex.statusCode} result with content ${JSON.stringify(ex.content)}`);
                return {
                    statusCode: ex.statusCode,
                    body: JSON.stringify(ex.content)
                }
            }
            console.error("An unhandled error occurred", ex);
            return {
                statusCode: 500,
                body: JSON.stringify({ message: "An error occurred"})
            }
        }
    }
}




/**
 * Pre-packaged response to make it easier to return a 201 with no content
 */
export const CreatedResponse: OperationResultWrapper<null> = {
    status: 201,
    content: null,
}

/**
 * Pre-packaged response to make it easier to return a 202 with no content
 */
export const AcceptedResponse: OperationResultWrapper<null> = {
    status: 202,
    content: null,
}


/**
 * Pre-packaged response to make it easier to return a 204 with no content
 */
export const NoContentResponse: OperationResultWrapper<null> = {
    status: 204,
    content: null,
}