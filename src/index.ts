import { Handler } from "aws-lambda";
import { SuccessResponse, OperationRequestBodyContent, ResponseObjectMap, FilterKeys, OkStatus } from "openapi-typescript-helpers"



/**
 * Interface that the handler expects
 */
export interface ApiCallInput {
    operationId: string
    body: string|null
    params: {
        path: Record<string,string> | undefined
        query: Record<string,string> | undefined
    };
}

/**
 * Result that the handler replies with.
 */
export interface ApiCallResult {
    statusCode: number
    body?: string|null
}

export type ApiCallHandler = Handler<ApiCallInput, ApiCallResult>;



export type OperationInput<OP> = {
    body: OperationRequestBodyContent<OP>
    params: FilterKeys<OP, "parameters">
}


// export type OperationJsonOutput<OP> = OperationResultWrapper<FilterKeys<ResponseObjectMap<OP>, OkStatus> extends { content: never } ? null : FilterKeys<SuccessResponse<ResponseObjectMap<OP>>, "application/json">>;

type Values<V> = V[keyof V];
type ObjectToAnyPair<V> = Values<{[K in keyof V]: {[K1 in K]: V[K1]}}>
export type OperationResponse<OP extends WithResponses> = ObjectToAnyPair<OP["responses"]>


type OperationMap = Record<string,WithResponses>;
type WithResponses = Record<string, any>


export type OperationHandler<OP extends OperationMap> = (props: OperationInput<OP>) => Promise<OperationResponse<OP>>

/**
 * List of all operations for a service against a function that can handle that operation
 * and return an appropriate 2xx response. In the event the operation has no 200 applicaiton/json
 * response, the return type will be void.
 * 
 * The return type will be based on the first 2xx response defined in the openAPI specification. 
 * If there are more than one 2xx responses, throw a Non2xxResult for any other values. 
 */
export type OperationHandlers<Ops extends OperationMap> = {
    [K in keyof Ops]: OperationHandler<Ops[K]>
};


/**
 * a Non-2xx response type to return to the caller. Each operation has only one normal response, 
 * which should be a 2xx type.  To allow other responses (sometimes called errors), throw one of 
 * these from within your code, and it will be returned as
 * such to the client.  This is less type-controlled than the main handlers, so make sure the generic
 * type that you specify here lines up with a type defined in your OpenAPI spec.
 */
export class Non2xxResult<C extends {}> extends Error {
    statusCode: number;
    content: C;

    constructor(content: C, statusCode: number = 500) {
        super("An non 2xx result has been returned");
        this.content = content;
        this.statusCode = statusCode;
    }
}


type GenericResponse = Record<string, {
    headers: Record<string,string>
    content: any
}>

/** 
 * Used to make the handler code below a bit more type safe.  It is reasonable to assume that every API 
 * generated by openapi-typescript will sort of conform to a more strict form of this shape
 */
type GenericOperation = {
    requestBody: {
        content: {
          "applicaiton/json": any
        };
    };
    parameters: {
        path: Record<string,string> | undefined,
        query: Record<string,string> | undefined,
    }
    responses: Record<string,GenericResponse>
}


/**
 * By default, the handler doesn't log anything.  If you supply DEBUG_API to the lambda's environment, it
 * will log instead. 
 */
function logDebug(msg: string) {
    if (process.env.DEBUG_API) {
        console.log(msg);
    }
}


function expectOnePair<T>(x: Record<string,T>): [string, T] {
    const entries = Object.entries(x);
    if (entries.length == 0) {
        throw new Non2xxResult({ message: "Handler returned no statuses"}, 500);
    }
    if (entries.length > 1) {
        throw new Non2xxResult({ message: "Handler returned multiple statuses"}, 500);
    }
    return entries[0];

}



/**
 * Creates an AWS Lambda compatible handler function that will take inputs in our custom format, call the appropriate
 * handler, then return the result. 
 * 
 * Note that the format used here is not the standard API Gateway Proxy request form.
 * 
 * @param apiHandler The input to pass to the API call - It is assumed that this has already been validated and is in a format appropriate for the operation being called.
 * @returns the result. 
 */
export function makeOpenApiLambdaHandler<OPS extends {}>(apiHandler: OperationHandlers<OPS>): Handler<ApiCallInput, ApiCallResult> {
    return async (evt) => {
        logDebug(`Invoking API ${JSON.stringify(evt)}`);    
        try {
            if (!(evt.operationId in apiHandler)) {
                return {
                    statusCode: 404,
                    body: JSON.stringify({ message: `Operation ${evt.operationId} not present`})
                }
            }
            const handler: OperationHandler<GenericOperation> = (apiHandler as any)[evt.operationId];
            const [statusCode, contentMap] = expectOnePair(await handler({
                body: evt.body && JSON.parse(evt.body) ,
                params: evt.params,
            }));
            const [contentType, result] = expectOnePair(contentMap);
            const resultContent = result.content ? JSON.stringify(result.content): undefined;
            logDebug(`Response ${statusCode} ${contentType}, ${resultContent}`);

            return {
                statusCode: parseInt(statusCode),
                headers: {
                    ...(result.headers as Record<string,string>),
                    "Content-Type": contentType
                },
                body: resultContent
            }
        } catch (ex: any) {
            if (ex instanceof Non2xxResult) {
                logDebug(`API raised ${ex.statusCode} result with content ${JSON.stringify(ex.content)}`);
                return {
                    statusCode: ex.statusCode,
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: typeof(ex.content) === 'string' ? ex.content : JSON.stringify(ex.content)
                }
            }
            console.error("An unhandled error occurred", ex);
            return {
                statusCode: 500,
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ message: "An error occurred"})
            }
        }
    }
}


export function makeJsonResponse<T>(content: T, status: number = 200) {
    const res: any =  {

    };
    res[status.toString()] = {
        "application/json": {
            content,
            headers: {}
        }
    }
}

export function makeErrorResponse(message: string, code: number = 500) {
    return makeJsonResponse({
        message,
    }, code);
}
